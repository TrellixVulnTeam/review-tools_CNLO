'''sr_lint.py: lint checks'''
#
# Copyright (C) 2013-2018 Canonical Ltd.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; version 3 of the License.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

from __future__ import print_function
from reviewtools.sr_common import (
    SnapReview,
)
from reviewtools.common import (
    find_external_symlinks,
    STORE_PKGNAME_SNAPV2_MAXLEN,
    STORE_PKGNAME_SNAPV2_MINLEN,
)
from reviewtools.overrides import (
    redflagged_snap_types_overrides,
    desktop_file_exception,
    lint_redflagged_base_dep_override,
)
import glob
import os
import re
import shlex
import unicodedata


class SnapReviewLint(SnapReview):
    '''This class represents snap lint reviews'''

    def __init__(self, fn, overrides=None):
        '''Set up the class.'''
        SnapReview.__init__(self, fn, "lint-snap-v2", overrides=overrides)
        if not self.is_snap2:
            return

        self.valid_compiled_architectures = ['armhf',
                                             'i386',
                                             'amd64',
                                             'arm64',
                                             'powerpc',
                                             'ppc64el',
                                             's390x',
                                             ]
        self.valid_architectures = ['all'] + self.valid_compiled_architectures
        self.vcs_files = ['.bzr*',
                          # '.excludes',  # autogenerated by SDK
                          '.git*',
                          '.idea',
                          '.svn*',
                          '.hg',
                          '.project',
                          'CVS*',
                          'RCS*'
                          ]
        self.iffy_files = [r'^\..+\.swp$',  # vim
                           ]

        self._list_all_compiled_binaries()

        self.redflagged_snap_types = ['base',
                                      'kernel',
                                      'gadget',
                                      'os',
                                      'snapd',
                                      ]

        self.interface_plug_requires_desktop_file = ['unity7',
                                                     'x11',
                                                     'unity8'
                                                     ]

    def check_architectures(self):
        '''Check architectures in snap.yaml is valid'''
        if not self.is_snap2:
            return

        t = 'info'
        n = self._get_check_name('architecture_valid')
        s = 'OK'

        key = 'architectures'
        if key not in self.snap_yaml:
            s = 'OK (%s not specified)' % key
            self._add_result(t, n, s)
            return

        if not isinstance(self.snap_yaml[key], list):
            t = 'error'
            s = "invalid %s entry: %s (not a list)" % (key,
                                                       self.snap_yaml[key])
        else:
            bad_archs = []
            for arch in self.snap_yaml[key]:
                if not isinstance(arch, str):
                    bad_archs.append(str(arch))
                elif arch not in self.valid_architectures:
                    bad_archs.append(arch)

                if len(bad_archs) > 0:
                    t = 'error'
                    s = "invalid multi architecture: %s" % ",".join(bad_archs)
        self._add_result(t, n, s)

    def check_assumes(self):
        '''Check assumes in snap.yaml is valid'''
        if not self.is_snap2:
            return

        t = 'info'
        n = self._get_check_name('assumes_valid')
        s = 'OK'

        key = 'assumes'
        if key not in self.snap_yaml:
            s = 'OK (%s not specified)' % key
            self._add_result(t, n, s)
            return

        if not isinstance(self.snap_yaml[key], list):
            t = 'error'
            s = "invalid %s entry: %s (not a list)" % (key,
                                                       self.snap_yaml[key])
        else:
            bad_assumes = []
            for a in self.snap_yaml[key]:
                if not isinstance(a, str):
                    bad_assumes.append(str(a))
            if len(bad_assumes) > 0:
                t = 'error'
                s = "invalid assumes: %s" % ",".join(bad_assumes)
        self._add_result(t, n, s)

    def _check_description_summary_title(self, key, maxlen):
        '''Check description, summary or title fields'''
        if not self.is_snap2:
            return

        t = 'info'
        n = self._get_check_name('%s_present' % key)
        s = 'OK'
        if key not in self.snap_yaml:
            s = 'OK (optional %s field not specified)' % key
            self._add_result(t, n, s)
            return
        self._add_result(t, n, s)

        t = 'info'
        n = self._get_check_name(key)
        s = 'OK'
        if not isinstance(self.snap_yaml[key], str):
            t = 'error'
            s = "invalid %s entry: %s (not a str)" % (key, self.snap_yaml[key])
            self._add_result(t, n, s)
            return
        elif len(self.snap_yaml[key]) < 1:
            t = 'error'
            s = "invalid %s entry (empty)" % (key)
        elif len(self.snap_yaml[key]) < len(self.snap_yaml['name']):
            t = 'info'
            s = "%s is too short: '%s'" % (key, self.snap_yaml[key])
        elif len(self.snap_yaml[key]) > maxlen:
            t = 'error'
            s = "%s is too long (> %d): '%s'" % (key, maxlen,
                                                 self.snap_yaml[key])
        self._add_result(t, n, s)

    def check_description(self):
        '''Check description'''
        # snap/validate.go
        self._check_description_summary_title("description", 4096)

    def check_summary(self):
        '''Check summary'''
        # should mirror the store, which is currently 128
        self._check_description_summary_title("summary", 128)

    def check_title(self):
        '''Check title'''
        # snap/validate.go
        self._check_description_summary_title("title", 40)

    def check_name(self):
        '''Check package name'''
        if not self.is_snap2:
            return

        t = 'info'
        n = self._get_check_name('name_valid')
        s = 'OK'
        if 'name' not in self.snap_yaml:
            t = 'error'
            s = "could not find 'name' in yaml"
        elif not isinstance(self.snap_yaml['name'], str):
            t = 'error'
            s = "malformed 'name': %s (not a str)" % (self.snap_yaml['name'])
        elif len(self.snap_yaml['name']) > STORE_PKGNAME_SNAPV2_MAXLEN:
            t = 'error'
            s = "malformed 'name': '%s' " % self.snap_yaml['name'] + \
                "(length '%d' " % len(self.snap_yaml['name']) + \
                "exceeds store limit '%d')" % STORE_PKGNAME_SNAPV2_MAXLEN
        elif len(self.snap_yaml['name']) < STORE_PKGNAME_SNAPV2_MINLEN:
            t = 'error'
            s = "malformed 'name': '%s' " % self.snap_yaml['name'] + \
                "(length '%d' " % len(self.snap_yaml['name']) + \
                "below store limit '%d')" % STORE_PKGNAME_SNAPV2_MINLEN
        elif not self._verify_pkgname(self.snap_yaml['name']):
            t = 'error'
            s = "malformed 'name': '%s' " % self.snap_yaml['name'] + \
                "(may be only lower case, digits and hyphens)"
        self._add_result(t, n, s)

    def check_type(self):
        '''Check type'''
        if not self.is_snap2 or 'type' not in self.snap_yaml:
            return

        t = 'info'
        n = self._get_check_name('snap_type_valid')
        s = 'OK'
        if self.snap_yaml['type'] not in self.valid_snap_types:
            t = 'error'
            s = "unknown 'type': '%s'" % self.snap_yaml['type']
        self._add_result(t, n, s)

    def check_type_redflagged(self):
        '''Check if type is redflagged'''
        if not self.is_snap2 or 'type' not in self.snap_yaml:
            return

        t = 'info'
        n = self._get_check_name('snap_type_redflag')
        s = "OK"
        manual_review = False
        if self.snap_yaml['type'] in self.redflagged_snap_types:
            pkgname = self.snap_yaml['name']
            snaptype = self.snap_yaml['type']
            if snaptype in redflagged_snap_types_overrides and \
                    pkgname in redflagged_snap_types_overrides[snaptype]:
                s = "OK (override '%s' for 'type: %s')" % (pkgname,
                                                           snaptype)
            else:
                t = 'error'
                s = "(NEEDS REVIEW) type '%s' not allowed" % \
                    self.snap_yaml['type']
                manual_review = True
        self._add_result(t, n, s, manual_review=manual_review)

    def check_version(self):
        '''Check package version'''
        if not self.is_snap2:
            return

        t = 'info'
        n = self._get_check_name('version_valid')
        s = 'OK'
        if 'version' not in self.snap_yaml:
            t = 'error'
            s = "could not find 'version' in yaml"
        elif isinstance(self.snap_yaml['version'], (str, int, float)) and \
                len(str(self.snap_yaml['version'])) > 32:
            t = 'error'
            s = "malformed 'version': '%s' (should be < 32 characters)" % \
                self.snap_yaml['version']
        elif not self._verify_pkgversion(self.snap_yaml['version']):
            t = 'error'
            s = "malformed 'version': '%s'" % self.snap_yaml['version']
        self._add_result(t, n, s)

    def check_valid_hook(self):
        '''Check valid hook'''
        if not self.is_snap2:
            return

        hooks = glob.glob("%s/meta/hooks/*" % self._get_unpack_dir())
        if len(hooks) == 0:
            return

        unknown = []
        for fn in hooks:
            hook = os.path.basename(fn)
            rel = os.path.relpath(fn, self._get_unpack_dir())
            t = 'info'
            n = self._get_check_name('hook_executable', app=hook)
            s = 'OK'
            if not self._check_innerpath_executable(fn):
                t = 'error'
                s = '%s is not executable' % rel
            self._add_result(t, n, s)

            found = False
            for valid in self.valid_hook_types:
                if hook == valid or \
                        (('-plug-' in hook or '-slot-' in hook) and
                         hook.startswith(valid)):
                    found = True
            if not found:
                unknown.append(hook)

        t = 'info'
        n = self._get_check_name('unknown_hook')
        s = 'OK'
        link = None
        if len(unknown) > 0:
            t = 'warn'
            s = "unknown hooks in meta/hooks: '%s'" % \
                (",".join(sorted(unknown)))
            link = 'https://forum.snapcraft.io/t/supported-snap-hooks/3795'
        self._add_result(t, n, s, link=link)

    def check_icon(self):
        '''Check icon'''
        # see docs/meta.md and docs/gadget.md
        if not self.is_snap2 or 'icon' not in self.snap_yaml:
            return

        # Snappy icons may be specified in the gadget snap.yaml, but not in
        # app snap.yaml. With apps, the icon may be in meta/gui/icon.png and
        # this file is optional. Therefore, for apps, there is nothing to do.
        t = 'info'
        n = self._get_check_name('icon_present')
        s = 'OK'
        if 'type' in self.snap_yaml and self.snap_yaml['type'] != "gadget":
            t = 'warn'
            s = 'icon only used with gadget snaps'
            self._add_result(t, n, s)
            return
        self._add_result(t, n, s)

        t = 'info'
        n = self._get_check_name('icon_empty')
        s = 'OK'
        if len(self.snap_yaml['icon']) == 0:
            t = 'error'
            s = "icon entry is empty"
            self._add_result(t, n, s)
            return
        self._add_result(t, n, s)

        t = 'info'
        n = self._get_check_name('icon_absolute_path')
        s = 'OK'
        if self.snap_yaml['icon'].startswith('/'):
            t = 'error'
            s = "icon entry '%s' should not specify absolute path" % \
                self.snap_yaml['icon']
        self._add_result(t, n, s)

        t = 'info'
        n = self._get_check_name('icon_exists')
        s = 'OK'
        fn = self._path_join(self._get_unpack_dir(), self.snap_yaml['icon'])
        if fn not in self.pkg_files:
            t = 'error'
            s = "icon entry '%s' does not exist" % self.snap_yaml['icon']
        self._add_result(t, n, s)

    def check_unknown_entries(self):
        '''Check for any unknown fields'''
        if not self.is_snap2:
            return

        t = 'info'
        n = self._get_check_name('unknown_field')
        s = 'OK'
        unknown = []
        for f in self.snap_yaml:
            if f not in self.snappy_required + self.snappy_optional:
                unknown.append(f)
        if len(unknown) > 0:
            t = 'warn'
            s = "unknown entries in snap.yaml: '%s'" % \
                (",".join(sorted(unknown)))
        self._add_result(t, n, s)

    def _verify_apps_and_hooks(self, hook=False):
        key = 'apps'
        key_type = 'app'
        required = self.apps_required
        optional = self.apps_optional
        if hook:
            key = 'hooks'
            key_type = 'hook'
            required = self.hooks_required
            optional = self.hooks_optional

        t = 'info'
        n = self._get_check_name('%s_present' % key)
        s = 'OK'
        if key not in self.snap_yaml:
            s = 'OK (optional %s field not specified)' % key
            self._add_result(t, n, s)
            return
        self._add_result(t, n, s)

        t = 'info'
        n = self._get_check_name(key)
        s = 'OK'
        if not isinstance(self.snap_yaml[key], dict):
            t = 'error'
            s = "invalid %s entry: %s (not a dict)" % (key,
                                                       self.snap_yaml[key])
            self._add_result(t, n, s)
            return
        elif len(self.snap_yaml[key].keys()) < 1:
            t = 'error'
            s = "invalid %s entry (empty)" % (key)
            self._add_result(t, n, s)
            return
        self._add_result(t, n, s)

        for val in self.snap_yaml[key]:
            t = 'info'
            n = self._get_check_name('%s_entry' % key, app=val)
            s = 'OK'

            if not isinstance(self.snap_yaml[key][val], dict):
                if key_type == 'hook' and self.snap_yaml[key][val] is None:
                    s = "OK (hook entry is empty)"
                else:
                    t = 'error'
                    s = "invalid entry: %s (not a dict)" % (
                        self.snap_yaml[key][val])
                self._add_result(t, n, s)
                continue
            elif key_type == 'app' and \
                    len(self.snap_yaml[key][val].keys()) < 1:
                t = 'error'
                s = "invalid entry for '%s' (empty)" % (val)
                self._add_result(t, n, s)
                continue
            elif not self._verify_appname(val):
                t = 'error'
                s = "malformed %s name: '%s'" % (key_type, val)
                self._add_result(t, n, s)
                continue
            self._add_result(t, n, s)

            for field in required:
                t = 'info'
                n = self._get_check_name('%s_required' % key, app=val)
                s = 'OK'
                if field not in self.snap_yaml[key][val]:
                    t = 'error'
                    s = "required field '%s' not specified" % field
                self._add_result(t, n, s)

            t = 'info'
            n = self._get_check_name('%s_unknown' % key, app=val)
            s = 'OK'
            unknown = []
            for field in self.snap_yaml[key][val]:
                if field not in required + optional:
                    unknown.append(field)
            if len(unknown) > 0:
                t = 'warn'
                s = "unknown fields for %s '%s': '%s'" % (
                    key_type, val, ",".join(sorted(unknown)))
            self._add_result(t, n, s)

    def check_apps(self):
        '''Check apps'''
        if not self.is_snap2:
            return
        self._verify_apps_and_hooks()

    def check_hooks(self):
        '''Check hooks'''
        if not self.is_snap2:
            return
        self._verify_apps_and_hooks(hook=True)

    def _verify_value_is_file(self, app, key, use_shell_quoting=False):
        t = 'info'
        n = self._get_check_name('%s' % key, app=app)
        s = 'OK'
        if not isinstance(self.snap_yaml['apps'][app][key], str):
            t = 'error'
            s = "%s '%s' (not a str)" % (key,
                                         self.snap_yaml['apps'][app][key])
            self._add_result(t, n, s)
        elif len(self.snap_yaml['apps'][app][key]) < 1:
            t = 'error'
            s = "invalid %s (empty)" % (key)
            self._add_result(t, n, s)
        else:
            if use_shell_quoting:
                try:
                    val = shlex.split(self.snap_yaml['apps'][app][key])[0]
                except ValueError:
                    t = 'error'
                    s = "invalid %s (unmatched quotes)" % (key)
                    self._add_result(t, n, s)
                    return
            else:
                val = self.snap_yaml['apps'][app][key]
            fn = self._path_join(self._get_unpack_dir(),
                                 os.path.normpath(val))
            if fn not in self.pkg_files:
                t = 'error'
                s = "%s does not exist" % (
                    self.snap_yaml['apps'][app][key])
        self._add_result(t, n, s)

    def check_apps_command(self):
        '''Check apps - command'''
        if not self.is_snap2 or 'apps' not in self.snap_yaml:
            return

        for app in self.snap_yaml['apps']:
            key = 'command'
            if key not in self.snap_yaml['apps'][app]:
                # We check for required elsewhere
                continue

            self._verify_value_is_file(app, key, True)

    def check_apps_command_chain(self):
        '''Check apps - command-chain'''
        if not self.is_snap2 or 'apps' not in self.snap_yaml:
            return

        for app in self.snap_yaml['apps']:
            key = 'command-chain'
            if key not in self.snap_yaml['apps'][app]:
                # We check for required elsewhere
                continue

            t = 'info'
            n = self._get_check_name('%s' % key, app=app)
            s = 'OK'
            if not isinstance(self.snap_yaml['apps'][app][key], list):
                t = 'error'
                s = "%s '%s' (not a list)" % (key,
                                              self.snap_yaml['apps'][app][key])
                self._add_result(t, n, s)
                continue
            elif len(self.snap_yaml['apps'][app][key]) < 1:
                t = 'error'
                s = "%s is empty" % key
                self._add_result(t, n, s)
                continue

            nonexistent = []
            for cmd in self.snap_yaml['apps'][app][key]:
                if not isinstance(cmd, str):
                    t = 'error'
                    s = "%s '%s' (not a str)" % (key, cmd)
                    self._add_result(t, n, s)
                    break
                elif len(cmd) < 1:
                    t = 'error'
                    s = "%s has an empty entry" % key
                    self._add_result(t, n, s)
                    break

                try:
                    val = shlex.split(cmd)[0]
                except ValueError:
                    t = 'error'
                    s = "invalid %s '%s' (unmatched quotes)" % (key, cmd)
                    self._add_result(t, n, s)
                    break

                fn = self._path_join(self._get_unpack_dir(),
                                     os.path.normpath(val))
                if fn not in self.pkg_files:
                    nonexistent.append(val)

                if len(nonexistent) != 0:
                    t = 'error'
                    plural = ''
                    if len(nonexistent) == 1:
                        plural = 'es'
                    s = "'%s' do%s not exist" % ("', '".join(nonexistent), plural)

                self._add_result(t, n, s)

    def check_apps_reload_command(self):
        '''Check apps - reload-command'''
        if not self.is_snap2 or 'apps' not in self.snap_yaml:
            return

        for app in self.snap_yaml['apps']:
            key = 'reload-command'
            if key not in self.snap_yaml['apps'][app]:
                # We check for required elsewhere
                continue

            self._verify_value_is_file(app, key, True)

    def check_apps_stop_command(self):
        '''Check apps - stop-command'''
        if not self.is_snap2 or 'apps' not in self.snap_yaml:
            return

        for app in self.snap_yaml['apps']:
            key = 'stop-command'
            if key not in self.snap_yaml['apps'][app]:
                # We check for required elsewhere
                continue

            self._verify_value_is_file(app, key, True)

    def check_apps_post_stop_command(self):
        '''Check apps - post-stop-command'''
        if not self.is_snap2 or 'apps' not in self.snap_yaml:
            return

        for app in self.snap_yaml['apps']:
            key = 'post-stop-command'
            if key not in self.snap_yaml['apps'][app]:
                # We check for required elsewhere
                continue

            self._verify_value_is_file(app, key, True)

    def _verify_timeout(self, app, key):
        '''Verify timeout for key'''
        suffix = 'ns|us|ms|s|m'
        t = 'info'
        n = self._get_check_name('%s' % key, app=app)
        s = "OK"
        if not isinstance(self.snap_yaml['apps'][app][key], int) and \
                not isinstance(self.snap_yaml['apps'][app][key], str):
            t = 'error'
            s = "'%s' is not a string or integer" % key
        elif not re.search(r'[0-9]+(%s)?$' % suffix,
                           str(self.snap_yaml['apps'][app][key])):
            t = 'error'
            s = "'%s' is not of form NN[ms] (%s)" % \
                (self.snap_yaml['apps'][app][key], key)
        self._add_result(t, n, s)

        if t == 'error':
            return

        t = 'info'
        n = self._get_check_name('%s_range' % key, app=app)
        s = "OK"
        st = int(re.sub(r'%s' % suffix, '',
                        str(self.snap_yaml['apps'][app][key])))
        if st < 0:
            t = 'error'
            s = "%s '%s' should be a positive" % (
                key, str(self.snap_yaml['apps'][app][key]))
        self._add_result(t, n, s)

    def check_apps_restart_delay(self):
        '''Check apps - restart-delay'''
        if not self.is_snap2 or 'apps' not in self.snap_yaml:
            return

        for app in self.snap_yaml['apps']:
            key = 'restart-delay'
            if key not in self.snap_yaml['apps'][app]:
                # We check for required elsewhere
                continue

            self._verify_timeout(app, key)

    def check_apps_start_timeout(self):
        '''Check apps - start-timeout'''
        if not self.is_snap2 or 'apps' not in self.snap_yaml:
            return

        for app in self.snap_yaml['apps']:
            key = 'start-timeout'
            if key not in self.snap_yaml['apps'][app]:
                # We check for required elsewhere
                continue

            self._verify_timeout(app, key)

    def check_apps_stop_timeout(self):
        '''Check apps - stop-timeout'''
        if not self.is_snap2 or 'apps' not in self.snap_yaml:
            return

        for app in self.snap_yaml['apps']:
            key = 'stop-timeout'
            if key not in self.snap_yaml['apps'][app]:
                # We check for required elsewhere
                continue

            self._verify_timeout(app, key)

    def check_apps_watchdog_timeout(self):
        '''Check apps - watchdog-timeout'''
        if not self.is_snap2 or 'apps' not in self.snap_yaml:
            return

        for app in self.snap_yaml['apps']:
            key = 'watchdog-timeout'
            if key not in self.snap_yaml['apps'][app]:
                # We check for required elsewhere
                continue

            self._verify_timeout(app, key)

    def _verify_valid_values(self, app, key, valid):
        '''Verify valid values for key in app'''
        t = 'info'
        n = self._get_check_name('%s' % key, app=app)
        s = 'OK'
        if not isinstance(self.snap_yaml['apps'][app][key], str):
            t = 'error'
            s = "%s '%s' (not a str)" % (key,
                                         self.snap_yaml['apps'][app][key])
            self._add_result(t, n, s)
        elif len(self.snap_yaml['apps'][app][key]) < 1:
            t = 'error'
            s = "invalid %s (empty)" % (key)
            self._add_result(t, n, s)
        elif self.snap_yaml['apps'][app][key] not in valid:
            t = 'error'
            s = "invalid %s: '%s'" % (key, self.snap_yaml['apps'][app][key])
        self._add_result(t, n, s)

    def check_apps_daemon(self):
        '''Check apps - daemon'''
        if not self.is_snap2 or 'apps' not in self.snap_yaml:
            return

        valid = ["simple",
                 "forking",
                 "oneshot",
                 "notify",
                 "dbus",
                 ]

        for app in self.snap_yaml['apps']:
            key = 'daemon'
            if key not in self.snap_yaml['apps'][app]:
                # We check for required elsewhere
                continue

            self._verify_valid_values(app, key, valid)

    def check_apps_invalid_combinations(self):
        '''Check apps - invalid combinations'''
        if not self.is_snap2 or 'apps' not in self.snap_yaml:
            return

        # Certain options require 'daemon' be specified
        for app in self.snap_yaml['apps']:
            needs_daemon = []
            if 'daemon' not in self.snap_yaml['apps'][app]:
                for key in self.snap_yaml['apps'][app]:
                    if key not in self.apps_optional:  # checked elsewhere
                        continue
                    if key in self.apps_optional_daemon:
                        needs_daemon.append(key)

            t = 'info'
            n = self._get_check_name('daemon_required', app=app)
            s = "OK"
            if len(needs_daemon) > 0:
                t = 'error'
                s = "'%s' must be used with 'daemon'" % ",".join(needs_daemon)
            self._add_result(t, n, s)

        # Certain options require 'daemon' not be specified
        for app in self.snap_yaml['apps']:
            needs_cli = []
            if 'daemon' in self.snap_yaml['apps'][app]:
                for key in self.snap_yaml['apps'][app]:
                    if key not in self.apps_optional:  # checked elsewhere
                        continue
                    if key in self.apps_optional_cli:
                        needs_cli.append(key)

            t = 'info'
            n = self._get_check_name('cli_required', app=app)
            s = "OK"
            if len(needs_cli) > 0:
                t = 'error'
                s = "'%s' must not be used with 'daemon'" % ",".join(needs_cli)
            self._add_result(t, n, s)

        # 'daemon: dbus' requires:
        # a) that 'bus-name' is specified and
        # b) that 'bus-name' matches one of the dbus slots
        for app in self.snap_yaml['apps']:
            if 'daemon' not in self.snap_yaml['apps'][app] or \
                    self.snap_yaml['apps'][app]['daemon'] != 'dbus':
                continue  # nothing to review

            t = 'info'
            n = self._get_check_name('dbus_bus-name_required', app=app)
            s = "OK"
            if 'bus-name' not in self.snap_yaml['apps'][app]:
                t = 'error'
                s = "use of 'daemon: dbus' requires 'bus-name'"
                self._add_result(t, n, s)
                continue
            elif not isinstance(self.snap_yaml['apps'][app]['bus-name'], str):
                t = 'error'
                s = "'bus-name' (not a str)"
                self._add_result(t, n, s)
                continue

            needle = self.snap_yaml['apps'][app]['bus-name']

            needs_slot = False
            if "slots" not in self.snap_yaml or \
                    not self._uses_interface("slots", "dbus"):
                needs_slot = True
            else:
                has_slot = False
                for ref in self.snap_yaml["slots"]:
                    spec = self.snap_yaml["slots"][ref]
                    if isinstance(spec, dict) and \
                            (('interface' not in spec and ref == 'dbus') or
                             ('interface' in spec and
                                 spec['interface'] == "dbus")) and \
                            'bus' in spec:
                        if 'slots' in self.snap_yaml['apps'][app] and \
                                ref in self.snap_yaml['apps'][app]['slots'] \
                                and spec['bus'] == "system" and \
                                'name' in spec and spec['name'] == needle:
                            # found a matching slot in the snap-wide slot or
                            # the app's slot
                            has_slot = True

                if not has_slot:
                    needs_slot = True

            t = 'info'
            n = self._get_check_name('dbus_slot_required', app=app)
            s = "OK"
            if needs_slot:
                t = 'error'
                s = "must use a dbus slot that matches 'bus: system' and " + \
                    "'name: %s'" % needle
            self._add_result(t, n, s)

        # commands should not mix dbus session and system slots
        for app in self.snap_yaml['apps']:
            show_report = False
            if 'slots' not in self.snap_yaml or \
                    len(self.snap_yaml['slots']) == 0:
                continue
            has_session = False
            has_system = False
            for ref in self.snap_yaml["slots"]:
                spec = self.snap_yaml["slots"][ref]
                if isinstance(spec, dict) and \
                        (('interface' not in spec and ref == 'dbus') or
                         ('interface' in spec and
                             spec['interface'] == "dbus")) and \
                        'bus' in spec:
                    show_report = True
                    if 'slots' in self.snap_yaml['apps'][app] and \
                            ref in self.snap_yaml['apps'][app]['slots']:
                        if spec['bus'] == "system":
                            has_system = True
                        elif spec['bus'] == "session":
                            has_session = True

            t = 'info'
            n = self._get_check_name('dbus_mixed_slots', app=app)
            s = "OK"
            if has_session and has_system:
                t = 'error'
                s = "Cannot specify both 'bus: session' and 'bus: system' " + \
                    "dbus slots in the same app"
            if show_report:
                self._add_result(t, n, s)

        # 'activatable: True' should be used with 'daemon: dbus'
        has_activatable = False
        for app in self.snap_yaml['apps']:
            if 'daemon' not in self.snap_yaml['apps'][app]:
                continue
            if 'slots' not in self.snap_yaml or \
                    len(self.snap_yaml['slots']) == 0:
                continue

            for ref in self.snap_yaml["slots"]:
                spec = self.snap_yaml["slots"][ref]
                if isinstance(spec, dict) and \
                        (('interface' not in spec and ref == 'dbus') or
                         ('interface' in spec and
                             spec['interface'] == "dbus")) and \
                        'activatable' in spec and spec['activatable']:
                    if 'slots' in self.snap_yaml['apps'][app] and \
                            ref in self.snap_yaml['apps'][app]['slots']:
                        has_activatable = True

            t = 'info'
            n = self._get_check_name('dbus_activatable', app=app)
            s = "OK"
            if has_activatable and \
                    self.snap_yaml['apps'][app]['daemon'] != 'dbus':
                t = 'warn'
                s = "'activatable: true' should be used with 'daemon: dbus'"
            self._add_result(t, n, s)

    def check_apps_restart_condition(self):
        '''Check apps - restart-condition'''
        if not self.is_snap2 or 'apps' not in self.snap_yaml:
            return

        valid = ["always",
                 "never",
                 "on-abnormal",
                 "on-abort",
                 "on-failure",
                 "on-success",
                 ]

        for app in self.snap_yaml['apps']:
            key = 'restart-condition'
            if key not in self.snap_yaml['apps'][app]:
                # We check for required elsewhere
                continue

            self._verify_valid_values(app, key, valid)

    def check_apps_ports(self):
        '''Check apps - ports'''
        if not self.is_snap2 or 'apps' not in self.snap_yaml:
            return

        valid_keys = ['internal', 'external']
        valid_subkeys = ['port', 'negotiable']
        for app in self.snap_yaml['apps']:
            if 'ports' not in self.snap_yaml['apps'][app]:
                # We check for required elsewhere
                continue

            t = 'info'
            n = self._get_check_name('ports', app=app)
            s = 'OK'
            link = None
            if not isinstance(self.snap_yaml['apps'][app]['ports'], dict):
                t = 'error'
                s = "ports '%s' (not a dict)" % (
                    self.snap_yaml['apps'][app]['ports'])
            elif len(self.snap_yaml['apps'][app]['ports'].keys()) < 1:
                t = 'error'
                s = "'ports' must contain 'internal' and/or 'external'"
            self._add_result(t, n, s, link)
            if t == 'error':
                continue

            # unknown
            unknown = []
            for key in self.snap_yaml['apps'][app]['ports']:
                if key not in valid_keys:
                    unknown.append(key)
            if len(unknown) > 0:
                t = 'error'
                n = self._get_check_name('ports_unknown_key', extra=key,
                                         app=app)
                s = "Unknown '%s' for ports" % (",".join(unknown))
                self._add_result(t, n, s)

            port_pat = re.compile(r'^[0-9]+/[a-z0-9\-]+$')
            for key in valid_keys:
                if key not in self.snap_yaml['apps'][app]['ports']:
                    continue

                if len(self.snap_yaml['apps'][app]['ports'][key].keys()) < 1:
                    t = 'error'
                    n = self._get_check_name('ports', extra=key, app=app)
                    s = 'Could not find any %s ports' % key
                    self._add_result(t, n, s)
                    continue

                for tagname in self.snap_yaml['apps'][app]['ports'][key]:
                    entry = self.snap_yaml['apps'][app]['ports'][key][tagname]
                    if len(entry.keys()) < 1 or ('negotiable' not in entry and
                                                 'port' not in entry):
                        t = 'error'
                        n = self._get_check_name('ports', extra=key, app=app)
                        s = "Could not find 'port' or 'negotiable' in '%s'" % \
                            tagname
                        self._add_result(t, n, s)
                        continue

                    # unknown
                    unknown = []
                    for subkey in entry:
                        if subkey not in valid_subkeys:
                            unknown.append(subkey)
                    if len(unknown) > 0:
                        t = 'error'
                        n = self._get_check_name('ports_unknown_subkey',
                                                 extra=key, app=app)
                        s = "Unknown '%s' for %s" % (",".join(unknown),
                                                     tagname)
                        self._add_result(t, n, s)

                    # port
                    subkey = 'port'
                    t = 'info'
                    n = self._get_check_name('ports_%s_format' % tagname,
                                             extra=subkey)
                    s = 'OK'
                    if subkey not in entry:
                        s = 'OK (skipped, not found)'
                    elif not isinstance(entry[subkey], str):
                        t = 'error'
                        s = "invalid entry: %s (not a str)" % (entry[subkey])
                    else:
                        tmp = entry[subkey].split('/')
                        if not port_pat.search(entry[subkey]) or \
                           int(tmp[0]) < 1 or int(tmp[0]) > 65535:
                            t = 'error'
                            s = "'%s' should be of form " % entry[subkey] + \
                                "'port/protocol' where port is an integer " + \
                                "(1-65535) and protocol is found in " + \
                                "/etc/protocols"
                    self._add_result(t, n, s)

                    # negotiable
                    subkey = 'negotiable'
                    t = 'info'
                    n = self._get_check_name('ports_%s_format' % tagname,
                                             extra=subkey)
                    s = 'OK'
                    if subkey not in entry:
                        s = 'OK (skipped, not found)'
                    elif not isinstance(entry[subkey], bool):
                        t = 'error'
                        s = "'%s: %s' should be either 'yes' or 'no'" % \
                            (subkey, entry[subkey])
                    self._add_result(t, n, s)

    def _verify_interfaces(self, iface_type):
        for iface in self.snap_yaml[iface_type]:
            # If the 'interface' name is the same as the 'iface' name, then
            # 'interface' is optional since the interface name and the iface
            # name are the same
            interface = iface

            spec = self.snap_yaml[iface_type][iface]
            if isinstance(spec, str):
                # Abbreviated syntax (no attributes)
                # <plugs|slots>:
                #   <alias>: <interface>
                interface = spec
            elif 'interface' in spec:
                # Full specification.
                # <plugs|slots>:
                #   <alias>:
                #     interface: <interface>
                interface = spec['interface']

            # Validate indirect (specified via alias) interfaces:
            if interface != iface:
                key = 'interface'
                t = 'info'
                n = self._get_check_name(iface_type, app=key, extra=interface)
                s = 'OK'
                if not isinstance(interface, str):
                    t = 'error'
                    s = "invalid %s: %s (not a str)" % (key, interface)
                elif len(interface) == 0:
                    t = 'error'
                    s = "'%s' is empty" % key
                self._add_result(t, n, s)
                if t == 'error':
                    continue

            # Check interfaces whitelist.
            t = 'info'
            n = self._get_check_name(iface_type, app=interface, extra=iface)
            s = 'OK'
            if interface not in self.interfaces:
                t = 'error'
                s = "unknown interface '%s'" % interface
            self._add_result(t, n, s)
            if t == 'error':
                continue

            # Abbreviated interfaces don't have attributes, done checking.
            if isinstance(spec, str):
                continue

            # Check interface attributes.
            for attrib in spec:
                if attrib == 'interface':
                    continue
                t = 'info'
                n = self._get_check_name('%s_attributes' % iface_type,
                                         app=iface, extra=attrib)
                s = "OK"
                attrib_key = "%s/%s" % (attrib, iface_type)
                if attrib_key not in self.interfaces[interface]:
                    t = 'error'
                    s = "unknown attribute '%s' for interface '%s' (%s)" % (
                        attrib, interface, iface_type)
                elif not isinstance(
                        spec[attrib], type(self.interfaces[interface][attrib_key])):
                    t = 'error'
                    s = "'%s' is not '%s'" % \
                        (attrib,
                         type(self.interfaces[interface][attrib_key]).__name__)
                self._add_result(t, n, s)

            # Check required interface attributes
            for req_iface in self.interfaces_required:
                if req_iface != interface or \
                   iface_type not in self.interfaces_required[interface]:
                    continue  # pragma: nocover

                has_required = False
                for req_attrib in self.interfaces_required[interface][iface_type]:
                    combo = req_attrib.split('/')
                    num_combos = 0     # total number of required attribs
                    found = 0          # required attribs found
                    found_invalid = 0  # must-not-have attribs found

                    for r in combo:
                        if not r.startswith('!'):
                            num_combos += 1

                        if r in spec:
                            found += 1
                        elif r.startswith('!') and r[1:] in spec:
                            found_invalid += 1

                    # if no invalid tokens and we found all the required
                    # attribs then we have a valid combination of required
                    # attribs
                    if found_invalid == 0 and found == num_combos:
                        has_required = True
                        break

                t = 'info'
                n = self._get_check_name('%s_required_attributes' % iface_type,
                                         app=iface)
                if not has_required:
                    # format the combinations for human review
                    combos = []
                    for req_attrib in self.interfaces_required[interface][iface_type]:
                        combo = []
                        for r in req_attrib.split('/'):
                            if not r.startswith('!'):
                                combo.append(r)
                        combos.append("/".join(combo))
                    t = 'error'
                    s = "missing required %s " % iface_type + \
                        "attributes for interface '%s' " % interface + \
                        "(%s)" % ", ".join(combos)
                self._add_result(t, n, s)

    def check_plugs(self):
        '''Check plugs'''
        iface_type = 'plugs'
        if not self.is_snap2 or iface_type not in self.snap_yaml:
            return

        self._verify_interfaces(iface_type)

    def _verify_app_and_hook_interfaces(self, val, key, hook=False):
        topkey = 'apps'
        topkey_type = 'app'
        if hook:
            topkey = 'hooks'
            topkey_type = 'hook'

        t = 'info'
        n = self._get_check_name("%s_%s" % (topkey_type, key), app=val)
        s = "OK"
        if not isinstance(self.snap_yaml[topkey][val][key], list):
            t = 'error'
            s = "invalid '%s' entry: '%s' (not a list)" % (
                key, self.snap_yaml[topkey][val][key])
        elif len(self.snap_yaml[topkey][val][key]) < 1:
            t = 'error'
            s = "invalid %s entry (empty)" % (key)
        self._add_result(t, n, s)
        if t == 'error':
            return

        # The interface referenced in the entry's 'key' field (plugs/slots) can
        # either be a known interface (when the interface name reference and
        # the interface is the same) or can reference a name in the snap's
        # toplevel 'key' (plugs/slots) mapping
        for ref in self.snap_yaml[topkey][val][key]:
            t = 'info'
            n = self._get_check_name('%s_%s_plug_reference' %
                                     (topkey_type, key),
                                     app=val,
                                     extra=ref)
            s = "OK"
            if not isinstance(ref, str):
                t = 'error'
                s = "invalid %s interface name reference: '%s' (not a str)" \
                    % (key, ref)
            elif ref not in self.interfaces and \
                    (key not in self.snap_yaml or
                     ref not in self.snap_yaml[key]):
                t = 'error'
                s = "unknown %s interface name reference '%s'" % (key, ref)
            self._add_result(t, n, s)
            if t == 'error':
                continue

    def check_apps_plugs(self):
        '''Check apps plugs'''
        if not self.is_snap2 or 'apps' not in self.snap_yaml:
            return

        for app in self.snap_yaml['apps']:
            key = 'plugs'
            if key not in self.snap_yaml['apps'][app]:
                continue

            self._verify_app_and_hook_interfaces(app, key)

    def check_hooks_plugs(self):
        '''Check hooks plugs'''
        if not self.is_snap2 or 'hooks' not in self.snap_yaml:
            return

        for hook in self.snap_yaml['hooks']:
            key = 'plugs'
            if self.snap_yaml['hooks'][hook] is None \
                    or key not in self.snap_yaml['hooks'][hook]:
                continue

            self._verify_app_and_hook_interfaces(hook, key, hook=True)

    def check_slots(self):
        '''Check slots'''
        iface_type = 'slots'
        if not self.is_snap2 or iface_type not in self.snap_yaml:
            return

        self._verify_interfaces(iface_type)

    def check_apps_slots(self):
        '''Check apps slots'''
        if not self.is_snap2 or 'apps' not in self.snap_yaml:
            return

        for app in self.snap_yaml['apps']:
            key = 'slots'
            if key not in self.snap_yaml['apps'][app]:
                continue

            self._verify_app_and_hook_interfaces(app, key)

    def check_external_symlinks(self):
        '''Check snap for external symlinks'''
        if not self.is_snap2:
            return

        # Note: unclear if gadget snaps can legitimately have external
        # symlinks, but err on side of caution. kernel snaps for reference
        # kernels ship a dangling lib/modules/.../build (like on desktop) but
        # also may have legitimate symlinks in lib/firmware, so just allow
        # them.
        if 'type' in self.snap_yaml and (self.snap_yaml['type'] == 'base' or
                                         self.snap_yaml['type'] == 'os' or
                                         self.snap_yaml['type'] == 'kernel'):
            return

        t = 'info'
        n = self._get_check_name('external_symlinks')
        s = 'OK'
        links = find_external_symlinks(self._get_unpack_dir(), self.pkg_files,
                                       self.snap_yaml['name'])
        if len(links) > 0:
            t = 'error'
            s = 'package contains external symlinks: %s' % ', '.join(links)
        self._add_result(t, n, s)

    def check_architecture_all(self):
        '''Check if actually architecture all'''
        if not self.is_snap2:
            return

        if 'architectures' in self.snap_yaml and \
                'all' not in self.snap_yaml['architectures']:
            return

        t = 'info'
        n = self._get_check_name('valid_contents_for_architecture')
        s = 'OK'

        # look for compiled code
        x_binaries = []
        for i in self.pkg_bin_files:
            # .pyc files are arch-independent
            if i.endswith(".pyc"):
                continue
            x_binaries.append(os.path.relpath(i, self._get_unpack_dir()))
        if len(x_binaries) > 0:
            x_binaries.sort()
            # gadget snap is specified with 'all' but has binaries. Don't complain
            # about that
            t = 'error'
            ok_text = ''
            if 'type' in self.snap_yaml and self.snap_yaml['type'] == 'gadget':
                t = 'info'
                ok_text = " (ok for 'type: gadget')"
            s = "found binaries for architecture 'all': %s%s" % \
                (", ".join(x_binaries), ok_text)
        self._add_result(t, n, s)

    def check_architecture_specified_needed(self):
        '''Check if the specified architecture is actually needed'''
        if not self.is_snap2 or 'architectures' not in self.snap_yaml:
            return

        if 'all' in self.snap_yaml['architectures']:
            return

        for arch in self.snap_yaml['architectures']:
            t = 'info'
            n = self._get_check_name('architecture_specified_needed',
                                     extra=arch)
            s = 'OK'
            if len(self.pkg_bin_files) == 0:
                # This should be a warning but it causes friction for uploads
                t = 'info'
                s = "Could not find compiled binaries for architecture '%s'" \
                    % arch
            self._add_result(t, n, s)

    def check_vcs(self):
        '''Check for VCS files in the package'''
        if not self.is_snap2:
            return

        t = 'info'
        n = self._get_check_name('vcs_files')
        s = 'OK'
        found = []
        for d in self.vcs_files:
            entries = glob.glob("%s/%s" % (self._get_unpack_dir(), d))
            if len(entries) > 0:
                for i in entries:
                    found.append(os.path.relpath(i, self.unpack_dir))
        if len(found) > 0:
            t = 'warn'
            s = 'found VCS files in package: %s' % ", ".join(found)
        self._add_result(t, n, s)

    def check_iffy(self):
        '''Check for iffy files in the package'''
        if not self.is_snap2:
            return

        t = 'info'
        n = self._get_check_name('iffy_files')
        s = 'OK'
        found = []

        for f in self.pkg_files:
            fn = os.path.basename(f)
            for d in self.iffy_files:
                if re.search(r'%s' % d, fn):
                    found.append(os.path.relpath(f, self.unpack_dir))

        if len(found) > 0:
            t = 'warn'
            s = 'found potentially sensitive files in package: %s' % \
                ", ".join(found)
        self._add_result(t, n, s)

    def check_epoch(self):
        '''Check epoch'''
        if not self.is_snap2 or 'epoch' not in self.snap_yaml:
            return

        t = 'info'
        n = self._get_check_name('epoch_valid')
        s = 'OK'

        # Valid formats:
        # - simple
        #   epoch: 0
        #   epoch: n (where n > 0)
        #   epoch: n* (where n > 0)
        # - full
        #   epoch:
        #     read: [n-1, n]
        #   epoch:
        #     write: [n-1, n]
        #   epoch:
        #     read: [n-2, n-1, n]
        #     write: [n-1, n]

        simple = "0 or positive integer with optional trailing '*'"

        if isinstance(self.snap_yaml['epoch'], int):  # epoch: n
            if int(self.snap_yaml['epoch']) < 0:
                t = 'error'
                s = "malformed 'epoch': '%s' should be %s" % (
                    self.snap_yaml['epoch'], simple)
        elif isinstance(self.snap_yaml['epoch'], str):  # epoch: n*
            if not re.search(r'^[0-9]+\*?$', self.snap_yaml['epoch']):
                t = 'error'
                s = "malformed 'epoch': '%s' should be %s" % (
                    self.snap_yaml['epoch'], simple)
        elif isinstance(self.snap_yaml['epoch'], dict):  # full syntax
            if len(self.snap_yaml['epoch']) == 0:
                t = 'error'
                s = 'malformed full syntax for epoch (empty)'
                self._add_result(t, n, s)
                return

            allowed = ['read', 'write']
            for k in self.snap_yaml['epoch']:
                if k not in allowed:
                    t = 'error'
                    s = "malformed full syntax for epoch: '%s' unknown" % k
                    self._add_result(t, n, s)
                    return

            for k in allowed:
                if k not in self.snap_yaml['epoch']:
                    continue
                if not isinstance(self.snap_yaml['epoch'][k], list):
                    t = 'error'
                    s = "malformed full syntax for epoch: '%s' not a list" % k
                    self._add_result(t, n, s)
                    return

                for i in self.snap_yaml['epoch'][k]:
                    if not isinstance(i, int):
                        t = 'error'
                        s = "malformed full syntax for epoch: '%s' " % k + \
                            "not a list of positive integers"
                        self._add_result(t, n, s)
                        return

                    if i < 0:
                        t = 'error'
                        s = "malformed 'epoch': '%s' in '%s' should be %s" % \
                            (i, k, simple)
                        self._add_result(t, n, s)
                        return
        else:
            t = 'error'
            s = "malformed 'epoch'. Should use simple syntax of '%s' or full syntax with read and/or write lists of positive integers"

        self._add_result(t, n, s)

    def check_confinement(self):
        '''Check confinement'''
        if not self.is_snap2 or 'confinement' not in self.snap_yaml:
            return

        allowed = ['strict', 'devmode', 'classic']
        use_with = ['app', 'gadget', 'kernel']

        t = 'info'
        n = self._get_check_name('confinement_valid')
        s = 'OK'
        manual_review = False
        if not isinstance(self.snap_yaml['confinement'], str):
            t = 'error'
            s = "malformed 'confinement': %s (not a string)" % (
                self.snap_yaml['confinement'])
        elif self.snap_yaml['confinement'] not in allowed:
            t = 'error'
            s = "malformed 'confinement': '%s' should be one of '%s'" % (
                self.snap_yaml['confinement'], ", ".join(allowed))
        elif self.snap_yaml['type'] not in use_with:
            t = 'info'
            s = "'confinement' should not be used with 'type: %s'" % \
                self.snap_yaml['type']
        self._add_result(t, n, s)

        if self.snap_yaml['confinement'] == "classic":
            t = 'info'
            n = self._get_check_name('confinement_classic')
            s = 'OK'
            manual_review = False
            link = None
            if self.overrides is not None and \
                    'snap_allow_classic' in self.overrides and \
                    self.overrides['snap_allow_classic']:
                s = "OK (confinement '%s' allowed)" % \
                    self.snap_yaml['confinement']
            else:
                t = 'error'
                s = "(NEEDS REVIEW) confinement '%s' not allowed. If your snap needs classic confinement to function, please make a request for this snap to use classic by creating a new topic in the forum using the 'store-requests' category and detail the technical reasons why classic is required." % \
                    self.snap_yaml['confinement']
                manual_review = True
                link = 'https://forum.snapcraft.io/t/process-for-reviewing-classic-confinement-snaps/1460'

            self._add_result(t, n, s, manual_review=manual_review, link=link)

            t = 'info'
            n = self._get_check_name('confinement_classic_with_interfaces')
            s = 'OK'
            link = None
            found = False
            if 'plugs' in self.snap_yaml or 'slots' in self.snap_yaml:
                found = True
            elif 'apps' in self.snap_yaml:
                for app in self.snap_yaml['apps']:
                    if 'plugs' in self.snap_yaml['apps'][app] or \
                            'slots' in self.snap_yaml['apps'][app]:
                        found = True
                        break
            if found:
                t = 'error'
                s = "confinement '%s' not allowed with plugs/slots" % \
                    self.snap_yaml['confinement']
                link = "https://launchpad.net/bugs/1655369"

            self._add_result(t, n, s, link=link)

    def check_grade(self):
        '''Check grade'''
        if not self.is_snap2 or 'grade' not in self.snap_yaml:
            return

        allowed = ['stable', 'devel']

        t = 'info'
        n = self._get_check_name('grade_valid')
        s = 'OK'
        if not isinstance(self.snap_yaml['grade'], str):
            t = 'error'
            s = "malformed 'grade': %s (not a string)" % (
                self.snap_yaml['grade'])
        elif self.snap_yaml['grade'] not in allowed:
            t = 'error'
            s = "malformed 'grade': '%s' should be one of '%s'" % (
                self.snap_yaml['grade'], ", ".join(allowed))
        self._add_result(t, n, s)

    def _verify_env(self, env, app=None):
        t = 'info'
        n = self._get_check_name('environment_valid', app=app)
        s = 'OK'

        if not isinstance(env, dict):
            t = 'error'
            s = "invalid environment: %s (not a dict)" % env
        self._add_result(t, n, s)

        # http://pubs.opengroup.org/onlinepubs/000095399/basedefs/xbd_chap08.html
        invalid = ['=', '\0']
        portable_pat = re.compile(r'^[A-Z_][A-Z0-9_]*$')
        lenient_pat = re.compile(r'^[a-zA-Z0-9_]+$')
        for key in env:
            t = 'info'
            n = self._get_check_name('environment_key_valid', app=app,
                                     extra=key)
            s = 'OK'
            link = None
            invalid_chars = []
            for c in invalid:
                if c in key:
                    invalid_chars.append(c)

            if len(invalid_chars) > 0:
                t = 'error'
                s = "found invalid characters '%s'" % ", ".join(invalid_chars)
            elif not portable_pat.search(key) and lenient_pat.search(key):
                t = 'info'
                s = "'%s' is not shell portable" % key
                link = "http://pubs.opengroup.org/onlinepubs/000095399/basedefs/xbd_chap08.html"
            elif not lenient_pat.search(key):
                t = 'warn'
                s = "unusual characters in '%s' " % key + \
                    "(should be '^[a-zA-Z0-9_]+$')"
            self._add_result(t, n, s, link=link)

            # The only limit on the contents of an arg appear to be the length
            # but that is going to be language and system dependent, so don't
            # worry about it here (this would simply be a bug in the software)
            t = 'info'
            n = self._get_check_name('environment_value_valid', app=app,
                                     extra=key)
            s = 'OK'
            if not isinstance(env[key], str) and \
                    not isinstance(env[key], int) and \
                    not isinstance(env[key], float):
                t = 'error'
                s = "invalid environment value for '%s': %s" % (key, env[key])
            self._add_result(t, n, s)

    def check_environment(self):
        '''Check environment'''
        if not self.is_snap2 or 'environment' not in self.snap_yaml:
            return

        self._verify_env(self.snap_yaml['environment'])

    def check_apps_environment(self):
        '''Check apps environment'''
        if not self.is_snap2 or 'apps' not in self.snap_yaml:
            return

        for app in self.snap_yaml['apps']:
            key = 'environment'
            if key not in self.snap_yaml['apps'][app]:
                continue

            self._verify_env(self.snap_yaml['apps'][app]['environment'],
                             app=app)

    def check_apps_aliases(self):
        '''Check apps aliases'''
        if not self.is_snap2 or 'apps' not in self.snap_yaml:
            return

        seen = []
        for app in self.snap_yaml['apps']:
            key = 'aliases'
            if key not in self.snap_yaml['apps'][app]:
                continue

            aliases = self.snap_yaml['apps'][app]['aliases']

            t = 'info'
            n = self._get_check_name('aliases_valid', app=app)
            s = 'OK'
            link = None
            if not isinstance(aliases, list):
                t = 'error'
                s = "invalid aliases: %s (not a list)" % aliases
            elif len(aliases) == 0:
                t = 'error'
                s = 'invalid aliases (empty)'
            else:
                # aliases are now deprectated:
                # https://forum.snapcraft.io/t/improving-the-aliases-implementation/18/38
                t = 'info'  # for now, soon will use WARN
                s = "DEPRECATED: support for using 'aliases' in the yaml " + \
                    "is being removed and will be replaced with snap " + \
                    "declarations. Please request a snap declaration via " + \
                    "the forum."
                link = "https://forum.snapcraft.io/t/process-for-reviewing-aliases-auto-connections-and-track-requests/455"
            self._add_result(t, n, s, link=link)

            # from validate.go in snapd
            pat = re.compile(r'^[a-zA-Z0-9][-_.a-zA-Z0-9]*$')
            for alias in aliases:
                t = 'info'
                n = self._get_check_name('alias_valid', app=app,
                                         extra=alias)
                if not pat.search(alias):
                    t = 'error'
                    s = "malformed alias '%s' " % alias + \
                        "(should be '^[a-zA-Z0-9][-_.a-zA-Z0-9]*$')"
                elif alias in seen:
                    t = 'error'
                    s = "alias '%s' used more than once" % alias
                self._add_result(t, n, s)
                seen.append(alias)

    def _uses_interface(self, iface_type, iface):
        '''Get interface name by type and interface/interface reference.
           Returns:
           - The dereferenced interface name
           - None if could not be found
        '''
        if iface_type in self.snap_yaml:
            for ref in self.snap_yaml[iface_type]:
                interface = ''
                spec = self.snap_yaml[iface_type][ref]
                if isinstance(spec, str):
                    # Abbreviated syntax (no attributes)
                    # <plugs|slots>:
                    #   <alias>: <interface>
                    interface = spec
                elif 'interface' in spec:
                    # Full specification.
                    # <plugs|slots>:
                    #   <alias>:
                    #     interface: <interface>
                    interface = spec['interface']
                elif isinstance(spec, dict):
                    # Abbreviated syntax (no attributes)
                    # <plugs|slots>:
                    #   <interface>: null
                    if len(spec) == 0:
                        interface = ref
                if interface == iface:
                    return True

        if 'apps' in self.snap_yaml:
            for app in self.snap_yaml['apps']:
                if iface_type in self.snap_yaml['apps'][app] and \
                        iface in self.snap_yaml['apps'][app][iface_type]:
                    return True

        return False

    def _verify_desktop_file(self, fn):
        '''Verify the desktop file'''
        if 'apps' not in self.snap_yaml:
            return

        appnames = []
        for app in self.snap_yaml['apps']:
            if app == self.snap_yaml['name']:
                appnames.append(app)
            else:
                appnames.append("%s.%s" % (self.snap_yaml['name'], app))

        fh = self._extract_file(fn)

        # For now, just check Exec= since snapd strips out anything it
        # doesn't understand. TODO: implement full checks
        found_exec = False
        t = 'info'
        n = self._get_check_name('desktop_file',
                                 extra=os.path.basename(fn))
        s = 'OK'
        for line in fh.readlines():
            line = line.rstrip()
            if line.startswith('Exec='):
                found_exec = True
                break
        if not found_exec:
            t = 'error'
            s = "Could not find 'Exec=' in desktop file"
        self._add_result(t, n, s)

    def check_meta_gui_desktop(self):
        '''Check meta/gui/*.desktop'''
        if not self.is_snap2:
            return

        default_provider_is_mir = False
        if self._uses_interface("plugs", "content"):
            if "plugs" in self.snap_yaml:
                for ref in self.snap_yaml["plugs"]:
                    spec = self.snap_yaml["plugs"][ref]
                    if isinstance(spec, dict) and \
                            'interface' in spec and \
                            spec['interface'] == "content" and \
                            'default-provider' in spec and \
                            spec['default-provider'] == "mir-kiosk":
                        default_provider_is_mir = True

        has_desktop_files = False
        for f in self.pkg_files:
            fn = os.path.relpath(f, self._get_unpack_dir())
            if fn.startswith("meta/gui/") and fn.endswith(".desktop"):
                self._verify_desktop_file(f)
                has_desktop_files = True
                break

        desktop_interfaces_specified = []
        for iface in self.interface_plug_requires_desktop_file:
            if self._uses_interface("plugs", iface):
                desktop_interfaces_specified.append(iface)

        if len(desktop_interfaces_specified) < 1 and not has_desktop_files:
            return

        t = 'info'
        n = self._get_check_name('meta_gui_desktop')
        s = 'OK'
        if len(desktop_interfaces_specified) > 0 and not has_desktop_files:
            if self.snap_yaml['name'] in desktop_file_exception:
                t = 'info'
                s = "OK (overidden)"
            elif self._uses_interface("plugs", "x11") and \
                    default_provider_is_mir:
                t = 'info'
                s = "OK (using x11 with mir-kiosk)"
            else:
                # LP: 1643910. We used to have this check because BAMF from
                # Unity 7 generated desktop files without considering snaps and
                # the snap run command, resulting in a desktop files with a
                # rewritten Exec= line that omitted snap run. This was fixed in
                # LP: #1747802 so now make this an info.
                t = 'info'
                s = "desktop interfaces " + \
                    "(%s) " % ",".join(desktop_interfaces_specified) + \
                    "specified without a corresponding meta/gui/*.desktop " + \
                    "file. If your application does not require a desktop " + \
                    "file, you may ignore this. Otherwise, if using " + \
                    "snapcraft, please see " + \
                    "https://snapcraft.io/docs/build-snaps/metadata#fixed-assets " + \
                    "or provide a desktop file in meta/gui/*.desktop (it " + \
                    "should reference one of the 'apps' from your " + \
                    "snapcraft/snap.yaml)."

        self._add_result(t, n, s)

    def check_apps_completer(self):
        '''Check apps - completer'''
        if not self.is_snap2 or 'apps' not in self.snap_yaml:
            return

        for app in self.snap_yaml['apps']:
            key = 'completer'
            if key not in self.snap_yaml['apps'][app]:
                continue

            self._verify_value_is_file(app, key)

    def check_base(self):
        '''Check base'''
        if not self.is_snap2 or 'base' not in self.snap_yaml:
            return

        use_with = ['app', 'gadget']

        t = 'info'
        n = self._get_check_name('base_valid')
        s = 'OK'
        if not isinstance(self.snap_yaml['base'], str):
            t = 'error'
            s = "malformed 'base': %s (not a string)" % (
                self.snap_yaml['base'])
        elif self.snap_yaml['type'] not in use_with:
            t = 'error'
            s = "'base' should not be used with 'type: %s'" % \
                self.snap_yaml['type']
        self._add_result(t, n, s)

        if isinstance(self.snap_yaml['base'], str) and \
                self.snap_yaml['base'] in lint_redflagged_base_dep_override:
            t = 'info'
            n = self._get_check_name('base_allowed')
            s = 'OK'
            manual_review = False
            if self.snap_yaml['name'] not in \
                    lint_redflagged_base_dep_override[self.snap_yaml['base']]:
                t = 'error'
                s = "(NEEDS REVIEW) not allowed to specify 'base: %s'" % \
                    self.snap_yaml['base']
                manual_review = True
            self._add_result(t, n, s, manual_review=manual_review)

    def check_base_interfaces(self):
        '''Check base interfaces'''
        if not self.is_snap2 or \
                'type' not in self.snap_yaml or \
                self.snap_yaml['type'] != 'base':
            return

        for i in ['plugs', 'slots']:
            t = 'info'
            n = self._get_check_name('base_interfaces', extra=i)
            s = 'OK'
            if i in self.snap_yaml:
                t = 'error'
                s = "'%s' not allowed with base snaps" % i
            self._add_result(t, n, s)

            if 'apps' in self.snap_yaml:
                for app in self.snap_yaml['apps']:
                    for j in ['plugs', 'slots']:
                        t = 'info'
                        n = self._get_check_name('base_interfaces', app=app,
                                                 extra=j)
                        s = 'OK'
                        if j in self.snap_yaml['apps'][app]:
                            t = 'error'
                            s = "'%s' not allowed with base snaps" % j
                        self._add_result(t, n, s)

    def check_license(self):
        '''Check license'''
        if not self.is_snap2 or 'license' not in self.snap_yaml:
            return

        t = 'info'
        n = self._get_check_name('license_valid')
        s = 'OK'
        if not isinstance(self.snap_yaml['license'], str):
            t = 'error'
            s = "malformed 'license': %s (not a string)" % (
                self.snap_yaml['license'])
        elif len(self.snap_yaml['license']) == 0:
            t = 'error'
            s = "invalid license entry (empty)"
        # TODO: validateSpdx (from snapd)
        self._add_result(t, n, s)

    def check_apps_sockets(self):
        '''Check apps - sockets'''
        if not self.is_snap2 or 'apps' not in self.snap_yaml:
            return

        for app in self.snap_yaml['apps']:
            key = 'sockets'
            if key not in self.snap_yaml['apps'][app]:
                # We check for required elsewhere
                continue

            if not isinstance(self.snap_yaml['apps'][app][key], dict):
                t = 'error'
                n = self._get_check_name('%s_type' % key, app=app)
                s = "invalid %s entry: %s (not a dict)" % \
                    (key, self.snap_yaml['apps'][app][key])
                self._add_result(t, n, s)
                continue

            for sockname in self.snap_yaml['apps'][app][key]:
                t = 'info'
                n = self._get_check_name(key, app=app, extra=sockname)
                s = "OK"
                # see validateSocketName() in snap/validate.go
                valid = True
                if not self._verify_pkgname(sockname):
                    t = 'error'
                    s = "malformed socket name: '%s' " % sockname + \
                        "(may be only lower case, digits and hyphens)"
                    valid = False
                self._add_result(t, n, s)
                if not valid:
                    continue

                # listen-stream
                # Per snap/validate.go, these are valid:
                # - $SNAP_DATA/...
                # - $SNAP_COMMON/...
                # - @snap.$SNAP_NAME....
                # - PORT (eg, 8080)
                # - 127.0.0.1|[::]|[::1]:PORT
                t = 'info'
                n = self._get_check_name('%s_listen_stream' % key, app=app,
                                         extra=sockname)
                s = "OK"

                if 'listen-stream' not in self.snap_yaml['apps'][app][key][sockname]:
                    t = 'error'
                    s = "missing required 'listen-stream'"
                    self._add_result(t, n, s)
                    continue

                st_isfile = False
                st = self.snap_yaml['apps'][app][key][sockname]['listen-stream']
                port = None
                try:
                    port = int(st)
                except Exception:
                    pass

                if port is not None:
                    if port < 1 or port > 65535:
                        t = 'error'
                        s = "port '%d' is not within 1-65535" % st
                elif not isinstance(st, str) or st == "":  # invalid
                    t = 'error'
                    s = "malformed listen-stream '%s' should use one of PORT, ADDR:PORT, @abstract-socket, or PATH" % st
                elif st.startswith("/") or st.startswith("$"):  # file
                    st_isfile = True
                    if st != os.path.normpath(st):
                        t = 'error'
                        s = "malformed listen-stream '%s' (rewrite as '%s')" % \
                            (st, os.path.normpath(st))
                    elif not re.search(r'^\$SNAP_(DATA|COMMON)/.+', st):
                        t = 'error'
                        s = "listen-stream '%s' filesystem paths does not start with $SNAP_DATA/... or $SNAP_COMMON/..." % st
                elif st.startswith("@"):  # abstract
                    if not st.startswith("@snap.%s." % self.snap_yaml['name']):
                        t = 'error'
                        s = "abstract socket '%s' does not start with 'snap.%s.'" % (st, self.snap_yaml['name'])
                else:  # network
                    if not re.search(r'^(127\.0\.0\.1|\[::\]|\[::1\]):[0-9]+', st):
                        t = 'error'
                        s = "network socket '%s' should use one of: 127.0.0.1:PORT, [::]:PORT, [::1]:PORT" % st
                self._add_result(t, n, s)

                # socket-mode
                t = 'info'
                n = self._get_check_name('%s_socket-mode' % key, app=app,
                                         extra=sockname)
                s = "OK"
                if 'socket-mode' not in self.snap_yaml['apps'][app][key][sockname]:
                    continue

                sm = self.snap_yaml['apps'][app][key][sockname]['socket-mode']

                if not isinstance(sm, int) and not isinstance(sm, str):
                    t = 'error'
                    s = "socket-mode '%s' should be an integer (eg, 0666)" % sm
                    self._add_result(t, n, s)
                    continue

                mode = None
                if isinstance(sm, str):
                    try:
                        mode = int(sm, 8)
                    except Exception:
                        t = 'error'
                        s = "socket-mode '%s' should be an integer (eg, 0666)" % sm
                        self._add_result(t, n, s)
                        continue
                else:
                    mode = sm

                if mode < 0o1 or mode > 0o777:
                    t = 'error'
                    s = "socket-mode '%s' must be within 1-777 octal" % format(mode, 'o')
                elif not st_isfile:
                    t = 'error'
                    s = "socket-mode should not be specified with abstract or network sockets"
                self._add_result(t, n, s)

    def check_apps_common_id(self):
        '''Check apps - common-id'''
        if not self.is_snap2 or 'apps' not in self.snap_yaml:
            return

        dupes = []
        seen = []

        for app in self.snap_yaml['apps']:
            key = 'common-id'
            if key not in self.snap_yaml['apps'][app]:
                # We check for required elsewhere
                continue

            t = 'info'
            n = self._get_check_name('%s' % key, app=app)
            s = 'OK'
            if not isinstance(self.snap_yaml['apps'][app][key], str):
                t = 'error'
                s = "%s '%s' (not a str)" % (key,
                                             self.snap_yaml['apps'][app][key])
            self._add_result(t, n, s)

            if self.snap_yaml['apps'][app][key] not in seen:
                seen.append(self.snap_yaml['apps'][app][key])
            else:
                dupes.append(self.snap_yaml['apps'][app][key])

        if len(dupes) > 0:
            n = self._get_check_name('%s_duplicates' % key, app=app)
            t = 'error'
            s = "%s specified more than once for: %s" % (key, ", ".join(dupes))
            self._add_result(t, n, s)

    def check_interface_content_slot_source(self):
        '''Check content interface slot source'''
        if not self.is_snap2 or 'slots' not in self.snap_yaml:
            return

        for slot in self.snap_yaml['slots']:
            iname = slot
            if 'interface' in self.snap_yaml['slots'][iname]:
                iname = self.snap_yaml['slots'][iname]['interface']

            if iname != 'content':
                continue

            iface = self.snap_yaml['slots'][slot]

            if 'source' not in iface:
                continue
            elif not isinstance(iface['source'], dict):
                t = 'error'
                n = self._get_check_name('%s_source_valid' % iname)
                s = "invalid content key: source (not a dict)"
                self._add_result(t, n, s)
                continue

            only_valid = True
            for key in iface['source'].keys():
                t = 'info'
                n = self._get_check_name('%s_source' % iname, app=key)
                s = 'OK'
                if key not in ['read', 'write']:
                    t = 'error'
                    n = self._get_check_name('%s' % iname, app=key)
                    s = "unknown content source key '%s'" % key
                elif not isinstance(iface['source'][key], list):
                    t = 'error'
                    n = self._get_check_name('%s_source_key_valid' % iname,
                                             app=key)
                    s = "invalid content source key: %s (not a list)" % (key)
                    self._add_result(t, n, s)
                    only_valid = False
                    continue
                else:
                    for i in iface['source'][key]:
                        if not isinstance(i, str):
                            t = 'error'
                            n = self._get_check_name('%s_source_item_valid' %
                                                     iname, app=key)
                            s = "content source %s values are not str" % key
                            self._add_result(t, n, s)
                            only_valid = False
                            break
                self._add_result(t, n, s)

            if not only_valid:
                continue

            if 'read' in iface['source'] and 'write' in iface['source']:
                both = []
                for i in iface['source']['read']:
                    if i in iface['source']['write']:
                        both.append(i)

                t = 'info'
                n = self._get_check_name('%s_source_in_both' % iname)
                s = 'OK'
                if len(both) > 0:
                    t = 'error'
                    s = "paths found in both read and write: %s" % \
                        ", ".join(both)
                    self._add_result(t, n, s)

    def check_layout(self):
        '''Check layout'''
        if not self.is_snap2 or 'layout' not in self.snap_yaml:
            return

        def _verify_layout_target(p):
            if '\0' in p or os.path.normpath(p) != p:
                return False
            return True

        def _verify_layout_source(p, allowed):
            if not _verify_layout_target(p):
                return False

            # we can't os.path.split a non-absolute path
            top = p.split('/')[0]
            if top not in allowed:
                return False

            return True

        key = 'layout'
        t = 'info'
        n = self._get_check_name(key)
        s = 'OK'
        if not isinstance(self.snap_yaml[key], dict):
            t = 'error'
            s = "invalid %s entry: %s (not a dict)" % (key,
                                                       self.snap_yaml[key])
            self._add_result(t, n, s)
            return
        elif len(self.snap_yaml[key].keys()) < 1:
            t = 'error'
            s = "invalid %s entry (empty)" % (key)
            self._add_result(t, n, s)
            return

        self._add_result(t, n, s)

        for target in self.snap_yaml[key]:
            t = 'info'
            n = self._get_check_name('%s_target' % key, app=target)
            s = 'OK'

            if not isinstance(self.snap_yaml[key][target], dict):
                t = 'error'
                s = "invalid entry: %s (not a dict)" % (
                    self.snap_yaml[key][target])
                self._add_result(t, n, s)
                continue
            elif len(self.snap_yaml[key][target].keys()) < 1:
                t = 'error'
                s = "invalid target '%s' (empty)" % (target)
                self._add_result(t, n, s)
                continue
            elif not _verify_layout_target(target):
                t = 'error'
                s = "invalid target mount: '%s'" % target
                self._add_result(t, n, s)
                continue
            self._add_result(t, n, s)

            # from snap/info_snap.go
            known = ['bind', 'bind-file', 'symlink', 'type', 'user', 'group',
                     'mode']
            for ltype in self.snap_yaml[key][target]:
                t = 'info'
                n = self._get_check_name('%s' % key, app=target,
                                         extra=ltype)
                s = 'OK'

                if ltype not in known:
                    t = 'error'
                    s = "invalid layout: '%s' (should be one of %s)" % \
                        (ltype, ", ".join(known))
                    self._add_result(t, n, s)
                    continue

                if ltype in ['bind', 'bind-file', 'symlink']:
                    target = target
                    source = self.snap_yaml[key][target][ltype]
                    t = 'info'
                    n = self._get_check_name('%s_source' % key, app=target,
                                             extra=source)
                    s = 'OK'

                    layout_prefixes = ["$SNAP", "$SNAP_COMMON", "$SNAP_DATA"]
                    if not isinstance(source, str):
                        t = 'error'
                        s = "invalid source: %s (not a str)" % source
                    elif not _verify_layout_source(source, layout_prefixes):
                        t = 'error'
                        s = "invalid source mount: '%s'" % source + \
                            "(should be a legal path and start with one " + \
                            "of: %s" % ", ".join(layout_prefixes)
                elif ltype == 'mode':
                    ltype = 'mode'
                    rdata = self.snap_yaml[key][target][ltype]
                    if not isinstance(rdata, int) and \
                            not isinstance(rdata, str):
                        t = 'error'
                        s = "invalid mode: should be an integer (eg, 0755)"
                        self._add_result(t, n, s)
                        continue

                    mode = None
                    if isinstance(rdata, str):
                        try:
                            mode = int(rdata, 8)
                        except Exception:
                            t = 'error'
                            s = "mode '%s' should be an integer " % rdata + \
                                "within 1-777 octal"
                            self._add_result(t, n, s)
                            continue
                    else:
                        mode = rdata

                    if mode < 0o1 or mode > 0o777:
                        t = 'error'
                        s = "mode '%s' must be within 1-777 octal" % \
                            format(mode, 'o')
                elif ltype == 'type':
                    ltype = 'type'
                    rdata = self.snap_yaml[key][target][ltype]
                    if not isinstance(rdata, str):
                        t = 'error'
                        s = "invalid %s (not a str)" % ltype
                        self._add_result(t, n, s)
                        continue

                    if rdata != 'tmpfs':
                        t = 'error'
                        s = "invalid type: %s != tmpfs" % rdata
                elif ltype in ['user', 'group']:
                    rdata = self.snap_yaml[key][target][ltype]
                    if not isinstance(rdata, str):
                        t = 'error'
                        s = "invalid %s (not a str)" % ltype
                        self._add_result(t, n, s)
                        continue

                    # Don't allow specifying uids
                    try:
                        int(self.snap_yaml[key][target][ltype])
                        t = 'error'
                        s = "invalid %s (should not be a number)" % ltype
                    except Exception:
                        pass

                self._add_result(t, n, s)

    def check_apps_refresh_mode(self):
        '''Check apps - refresh-mode'''
        if not self.is_snap2 or 'apps' not in self.snap_yaml:
            return

        unknown = []
        for app in self.snap_yaml['apps']:
            key = 'refresh-mode'
            if key not in self.snap_yaml['apps'][app]:
                # We check for required elsewhere
                continue

            t = 'info'
            n = self._get_check_name('%s' % key, app=app)
            s = 'OK'
            if not isinstance(self.snap_yaml['apps'][app][key], str):
                t = 'error'
                s = "%s '%s' (not a str)" % (key,
                                             self.snap_yaml['apps'][app][key])
                self._add_result(t, n, s)
                continue
            self._add_result(t, n, s)

            refresh_mode = self.snap_yaml['apps'][app][key]
            if refresh_mode not in self.valid_refresh_modes and \
                    refresh_mode not in unknown:
                unknown.append(refresh_mode)

        t = 'info'
        n = self._get_check_name('unknown_refresh_mode')
        s = 'OK'
        if len(unknown) > 0:
            t = 'warn'
            s = "unknown refresh-mode: '%s'" % \
                (",".join(sorted(unknown)))
        self._add_result(t, n, s)

    def check_apps_stop_mode(self):
        '''Check apps - stop-mode'''
        if not self.is_snap2 or 'apps' not in self.snap_yaml:
            return

        unknown = []
        for app in self.snap_yaml['apps']:
            key = 'stop-mode'
            if key not in self.snap_yaml['apps'][app]:
                # We check for required elsewhere
                continue

            t = 'info'
            n = self._get_check_name('%s' % key, app=app)
            s = 'OK'
            if not isinstance(self.snap_yaml['apps'][app][key], str):
                t = 'error'
                s = "%s '%s' (not a str)" % (key,
                                             self.snap_yaml['apps'][app][key])
                self._add_result(t, n, s)
                continue
            self._add_result(t, n, s)

            stop_mode = self.snap_yaml['apps'][app][key]
            if stop_mode not in self.valid_stop_modes and \
                    stop_mode not in unknown:
                unknown.append(stop_mode)

        t = 'info'
        n = self._get_check_name('unknown_stop_mode')
        s = 'OK'
        if len(unknown) > 0:
            t = 'warn'
            s = "unknown stop-mode: '%s'" % \
                (",".join(sorted(unknown)))
        self._add_result(t, n, s)

    def check_snap_manifest(self):
        '''Check snap/manifest.yaml'''
        if not self.is_snap2 or len(self.snap_manifest_yaml) == 0:
            return

        t = 'info'
        n = self._get_check_name('snap_manifest')
        s = 'OK'

        (valid, t, s) = self.verify_snap_manifest(self.snap_manifest_yaml)
        self._add_result(t, n, s)

    def check_apps_timer(self):
        '''Check apps - timer'''
        if not self.is_snap2 or 'apps' not in self.snap_yaml:
            return

        # timers are a complex format. For now, let's just use a simple regex
        timer_pat = re.compile(r'^([0-9:~/,\-]|mon|tue|wed|thu|fri|sat|sun)+$')
        key = 'timer'
        for app in self.snap_yaml['apps']:
            if key not in self.snap_yaml['apps'][app]:
                # We check for required elsewhere
                continue

            t = 'info'
            n = self._get_check_name('%s' % key, app=app)
            s = 'OK'
            if not isinstance(self.snap_yaml['apps'][app][key], str) and \
                    not isinstance(self.snap_yaml['apps'][app][key], int):
                t = 'error'
                s = "%s '%s' (not a str or int)" % (
                    key, self.snap_yaml['apps'][app][key])
                self._add_result(t, n, s)
                continue

            # 24:00 is an int in json
            timer = str(self.snap_yaml['apps'][app][key])
            if not timer_pat.search(timer):
                t = 'error'
                s = "'%s' not a valid timer" % timer
            self._add_result(t, n, s)

    def check_apps_before_after(self):
        '''Check apps - before/after'''
        if not self.is_snap2 or 'apps' not in self.snap_yaml:
            return

        for key in ['after', 'before']:
            for app in self.snap_yaml['apps']:
                if key not in self.snap_yaml['apps'][app]:
                    continue

                t = 'info'
                n = self._get_check_name('%s' % key, app=app)
                s = 'OK'
                if not isinstance(self.snap_yaml['apps'][app][key], list):
                    t = 'error'
                    s = "%s '%s' (not a list)" % (
                        key, self.snap_yaml['apps'][app][key])
                    self._add_result(t, n, s)
                    continue

                if len(self.snap_yaml['apps'][app][key]) == 0:
                    t = 'error'
                    s = "%s '%s' (empty)" % (
                        key, self.snap_yaml['apps'][app][key])
                    self._add_result(t, n, s)
                    continue

                for key_app in self.snap_yaml['apps'][app][key]:
                    if not isinstance(key_app, str):
                        t = 'error'
                        n = self._get_check_name('%s' % key, app=app,
                                                 extra=key_app)
                        s = "%s '%s' (not a str)" % (
                            key, self.snap_yaml['apps'][app][key])
                        self._add_result(t, n, s)
                        continue

                    t = 'info'
                    n = self._get_check_name('%s_exists' % key, app=app,
                                             extra=key_app)
                    s = 'OK'
                    if key_app not in self.snap_yaml['apps']:
                        t = 'error'
                        s = "Could not find non-existent app '%s' for '%s'" % \
                            (key_app, key)
                    self._add_result(t, n, s)

    def _has_invalid_unicode(self, value, allow_newlines=True):
        '''Check if string contains invalid unicode chars'''
        invalid = \
            set(ch for ch in value
                if (unicodedata.category(ch)[0] == "C" or ch == "\uFFFD") and
                not (ch == '\n' and allow_newlines))
        if not invalid:
            return ""

        if invalid == {'\n'}:
            return "newlines not allowed"

        return "control/private unicode characters not allowed"

    def check_unicode_fields(self):
        '''Check various fields for valid unicode'''
        if not self.is_snap2:
            return

        errors = []
        for field in self.snappy_required + self.snappy_optional:
            if field not in self.snap_yaml:
                continue

            # These fields are verified elsewhere, so just check all fields
            # that are strings
            if not isinstance(self.snap_yaml[field], str):
                continue

            newlines_ok = False
            if field == 'description':
                newlines_ok = True

            res = self._has_invalid_unicode(self.snap_yaml[field], newlines_ok)
            if res != "":
                errors.append("'%s' invalid: %s" % (field, res))

        t = 'info'
        n = self._get_check_name('valid_unicode')
        s = 'ok'
        if len(errors) > 0:
            t = 'error'
            s = "found errors in file output: %s" % ", ".join(errors)
        self._add_result(t, n, s)

    def check_apps_autostart(self):
        '''Check apps - autostart'''
        if not self.is_snap2 or 'apps' not in self.snap_yaml:
            return

        # We intentionally don't check for existence since the application may
        # create the .desktop file on the fly in
        # $SNAP_USER_DATA/.config/autostart
        for app in self.snap_yaml['apps']:
            key = 'autostart'
            if key not in self.snap_yaml['apps'][app]:
                # We check for required elsewhere
                continue

            dname = self.snap_yaml['apps'][app][key]

            t = 'info'
            n = self._get_check_name('%s' % key, app=app)
            s = 'OK'
            if not isinstance(dname, str):
                t = 'error'
                s = "%s '%s' (not a str)" % (key, dname)
            elif not dname.endswith('.desktop'):
                t = 'error'
                s = "'%s' does not end with '.desktop'" % (dname)
            elif not re.search(r'^[a-zA-Z0-9._-]+$', dname):
                # https://specifications.freedesktop.org/desktop-entry-spec/latest/ar01s02.html
                # https://dbus.freedesktop.org/doc/dbus-specification.html#message-protocol-names
                # The specification says a desktop file must be a valid DBus
                # name. Since there are exceptions for what is allowed to under
                # various circumstances, just do a simple match (if needed,
                # this can be fine-tuned in the future. For simplicity, don't
                # strip the .desktop extension since it is already valid.
                t = 'error'
                s = "malformed desktop file name ('%s'). Should consist of only: [a-zA-Z0-9._-]" % (dname)
            self._add_result(t, n, s)

    def check_interface_personal_system_files_plugs(self):
        '''Check personal-files/system-files interface plug attributes'''
        if not self.is_snap2 or 'plugs' not in self.snap_yaml:
            return

        for plug in self.snap_yaml['plugs']:
            iname = plug
            if 'interface' in self.snap_yaml['plugs'][iname]:
                iname = self.snap_yaml['plugs'][iname]['interface']

            if iname not in ['personal-files', 'system-files']:
                continue

            iface = self.snap_yaml['plugs'][plug]

            for attrib in ['read', 'write']:
                if attrib not in iface:
                    continue
                if not isinstance(iface[attrib], list):
                    t = 'error'
                    n = self._get_check_name('%s_attrib_valid' % iname,
                                             app=attrib)
                    s = "invalid attribute: %s (not a list)" % attrib
                    self._add_result(t, n, s)
                    continue

                for entry in iface[attrib]:
                    if not isinstance(entry, str):
                        t = 'error'
                        n = self._get_check_name('%s_valid' % iname,
                                                 app=attrib)
                        s = "invalid entry: %s (not a str)" % entry
                        self._add_result(t, n, s)
                        continue

                    t = 'info'
                    n = self._get_check_name('%s_path' % iname,
                                             app=attrib)
                    s = 'OK'
                    if (iname == 'personal-files' and
                            not entry.startswith('$HOME/')) or \
                            (iname == 'system-files' and
                             not entry.startswith('/')):
                        t = 'error'
                        suggested = '/'
                        if iname == 'personal-files':
                            suggested = '$HOME'
                        s = "invalid path for entry: %s " % entry + \
                            "(should start with '%s')" % suggested
                    elif '\0' in entry or os.path.normpath(entry) != entry:
                        t = 'error'
                        s = "invalid path: %s " % entry

                    self._add_result(t, n, s)

    def check_system_users(self):
        '''Check system-users'''
        if not self.is_snap2 or 'system-users' not in self.snap_yaml:
            return

        t = 'info'
        n = self._get_check_name('system-users_valid')
        s = 'OK'
        if not isinstance(self.snap_yaml['system-users'], list):
            t = 'error'
            s = "malformed 'system-users': %s (not a list)" % (
                self.snap_yaml['system-users'])
        elif len(self.snap_yaml['system-users']) == 0:
            t = 'error'
            s = "empty 'system-users'"
        else:
            for i in self.snap_yaml['system-users']:
                if not isinstance(i, str):
                    t = 'error'
                    s = "malformed entry in 'system-users': " + \
                        "%s (contains non-strings)" % \
                        self.snap_yaml['system-users']
                    break

        self._add_result(t, n, s)
