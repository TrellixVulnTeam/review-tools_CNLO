#!/usr/bin/python3
# Copyright (C) 2018 Canonical Ltd.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; version 3 of the License.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

#
# NOTE: the initial implementation of this has no store integration support
# and will look at:
# - USN db for usn information (ie, only packages in main and restricted from
#   Ubuntu are reported). The USN db will only move forward with USNs only
#   being added and not removed.
# - raw store db (contains only revisions that currently in a channel or
#   track/channel). Because the store db contains only the current published
#   revisions, as new snap revisions are published, old snap revisions will
#   be removed. Note that only snaps built with snapcraft using
#   SNAPCRAFT_BUILD_INFO=1 will appear in the raw store db.
#
# The overall intent of this implementation is to inform, not nag. As such:
# - a new snap with no previous revisions will have all USNs that affect it
#   reported. Nothing is reported if no USNs affect it
# - a snap that previously had USNs reported where the revision is unchanged
#   but a new USN affects it will only have the new USN reported
# - a snap that is reverted to an older revision (ie, this revision, though
#   older, is new in the raw store db) with USNs that affect it will have all
#   USNs reported
#
# The 'seen db' will be used to control when reports are sent
#

import argparse
import json
import os
import pprint
import shutil
import sys
import tempfile
import textwrap
import yaml

import clickreviews.common as common
import clickreviews.email as email

from clickreviews.common import (
    debug,
    error,
    warn,
    read_file_as_json_dict,
    _add_error,  # make a class
)
from clickreviews.store import (
    get_pkg_revisions,
    get_shared_snap_without_override,
    get_usns_for_manifest,
)
from clickreviews.usn import (
    read_usn_db,
)


# The From address for all emails
email_from_addr = "Snap Store <noreply@canonical.com>"

# Send via local SMTP server
email_server = 'localhost'


#
# Helpers
#
def get_snap_manifest(fn):
    if 'SNAP_USER_COMMON' in os.environ and \
            os.path.exists(os.environ['SNAP_USER_COMMON']):
        common.MKDTEMP_DIR = os.environ['SNAP_USER_COMMON']
    else:
        common.MKDTEMP_DIR = tempfile.gettempdir()

    man = "snap/manifest.yaml"
    # common.unpack_pkg() fails if this exists, so this is safe
    dir = tempfile.mktemp(prefix=common.MKDTEMP_PREFIX, dir=common.MKDTEMP_DIR)
    common.unpack_pkg(fn, dir, man)

    man_fn = os.path.join(dir, man)
    if not os.path.isfile(man_fn):
        common.recursive_rm(dir)
        error("%s not in %s" % (man, fn))

    fd = common.open_file_read(man_fn)
    try:
        man_yaml = yaml.safe_load(fd)
    except Exception:
        common.recursive_rm(dir)
        error("Could not load snap/manifest.yaml. Is it properly formatted?")

    common.recursive_rm(dir)

    return man_yaml


def generate_report(pkg_db, seen_db):
    '''Generate a report for this pkg, consulting seen_db'''
    pkgname = pkg_db['name']

    report = '''A scan of this snap shows that it was built with packages from the Ubuntu
archive that have since received security updates. The following lists new USNs
for affected binary packages in each snap revision:
'''

    reference_urls = []

    for r in sorted(pkg_db['revisions']):
        if len(pkg_db['revisions'][r]['usn-report']) == 0:
            continue

        architectures = pkg_db['revisions'][r]['architectures']
        architectures.sort()
        architectures = ", ".join(architectures)

        rev_header = "\nRevision r%s (%s; channel%s: %s)" % \
            (r, architectures,
             "s" if len(pkg_db['revisions'][r]['channels']) > 0 else "",
             ", ".join(pkg_db['revisions'][r]['channels']))
        shown_rev_header = False

        for p in sorted(pkg_db['revisions'][r]['usn-report']):
            usns = []
            for usn in pkg_db['revisions'][r]['usn-report'][p]:
                # only report new USNs, unless we don't know about this
                # revision
                if pkgname in seen_db and r in seen_db[pkgname] and \
                        usn in seen_db[pkgname][r]:
                    continue
                usns.append(usn)
            usns.sort()

            if len(usns) > 0:
                if not shown_rev_header:
                    report += rev_header
                    shown_rev_header = True
                report += "\n * %s: %s" % (p, ", ".join(usns))

            for usn in usns:
                url = "https://usn.ubuntu.com/%s/" % usn
                if url not in reference_urls:
                    reference_urls.append(url)

        if shown_rev_header:
            report += "\n"

    if len(reference_urls) == 0:
        # nothing to report
        return ""

    report += '''
Simply rebuilding the snap will pull in the new security updates and resolve
this. If your snap also contains vendored code, now might be a good time to
review it for any needed updates.

Thank you for your snap and for attending to this matter.
'''

    reference_urls.sort()
    report += '''
References:
 * %s
''' % "\n * ".join(reference_urls)

    return report


def email_report(pkg_db, seen_db):
    '''Send email report for this pkgname'''
    pkgname = pkg_db['name']

    body = generate_report(pkg_db, seen_db)
    if body == "":
        return False

    subj = "%s contains outdated Ubuntu packages" % pkgname

    # Send to the publisher and any affected uploaders
    email_to_addr = pkg_db['publisher']
    if len(pkg_db['uploaders']) > 0:
        email_to_addr += ", %s" % ", ".join(pkg_db['uploaders'])
    if len(pkg_db['additional']) > 0:
        email_to_addr += ", %s" % ", ".join(pkg_db['additional'])
    email_to_addr += ", security@ubuntu.com"

    email.send(email_to_addr, subj, body)

    debug("Sent email for '%s'" % pkgname)
    return True


def read_seen_db(fn):
    if not os.path.exists(fn):
        # write out an empty seen_db
        with common.open_file_write(fn) as fd:
            fd.write('{}\n')
            fd.close()

    return read_file_as_json_dict(fn)


def update_seen(seen_fn, seen_db, pkg_db):
    pkgname = pkg_db['name']
    if pkgname not in seen_db:
        seen_db[pkgname] = {}

    # update to add new revisions
    for r in pkg_db['revisions']:
        if len(pkg_db['revisions'][r]['usn-report']) == 0:
            continue

        if r not in seen_db[pkgname]:
            seen_db[pkgname][r] = []

        for p in pkg_db['revisions'][r]['usn-report']:
            for usn in pkg_db['revisions'][r]['usn-report'][p]:
                if usn not in seen_db[pkgname][r]:
                    seen_db[pkgname][r].append(usn)
        seen_db[pkgname][r].sort()

    # remove old revisions
    remove = []
    for r in seen_db[pkgname]:
        if r not in pkg_db['revisions']:
            remove.append(r)
    if len(remove) > 0:
        for r in remove:
            del seen_db[pkgname][r]

    # TODO: update seen more efficiently (right now it is only 70k so not a
    # huge deal, but should probably move to sqlite)
    (fd, fn) = tempfile.mkstemp(prefix=common.MKDTEMP_PREFIX)
    os.write(fd, bytes(json.dumps(seen_db, sort_keys=True, indent=2), 'UTF-8'))
    os.close(fd)

    shutil.move(fn, seen_fn)


def main():
    common.REPORT_OUTPUT = "console"
    parser = argparse.ArgumentParser(
        prog='snap-updates-available',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        description='Show report of available security updates',
        epilog=textwrap.dedent('''\
            Typical usage:
            $ %s --usn-db=/usn/db --store-db=/store/db --seen-db=/seen/db
        ''' % os.path.basename(sys.argv[0])))

    parser.add_argument('--snap', type=str,
                        help='use manifest.yaml from snap')
    parser.add_argument('--check-shared-publishers',
                        help='Report snaps missing publisher overrides',
                        action='store_true')
    parser.add_argument('--usn-db', type=str,
                        help='USN database (json)')
    parser.add_argument('--store-db', type=str,
                        help='Raw store db (json)')
    parser.add_argument('--seen-db', type=str,
                        help='Previously seen db (json)')
    parser.add_argument('--pkg-name', type=str,
                        help='Limit report to package name')
    args = parser.parse_args()

    # XXX: for as nice as argparse is, our arg processing is less than clear
    if args.check_shared_publishers:
        if args.snap:
            error("--snap should not be used with --check-shared-publishers")

        if not args.store_db:
            error("Must specify --store-db with --check-shared-publishers")
        store_db = read_file_as_json_dict(args.store_db)
        report = get_shared_snap_without_override(store_db)

        if len(report) != 0:
            print("The following snaps are missing from overrides.py:\n")
            for eml in sorted(report):
                print("%s:\n- %s" % (eml, "\n- ".join(report[eml])))
            # pprint.pprint(report)

        return

    if args.snap:
        if not args.usn_db:
            error("Must specify --usn-db with --snap")
        if args.store_db:
            error("Must not specify --store-db with --snap")

    if not args.snap and not args.store_db:
        error("Must specify --snap or --store-db")

    usn_db = read_usn_db(args.usn_db)

    if args.snap:
        m = get_snap_manifest(args.snap)

        report = get_usns_for_manifest(m, usn_db)
        if len(report) != 0:
            pprint.pprint(report)
    elif args.store_db:
        store_db = read_file_as_json_dict(args.store_db)

        if args.seen_db:
            seen_db = read_seen_db(args.seen_db)
        else:
            seen_db = {}

        errors = {}
        # TODO: capture these continues errors at the end
        for item in store_db:
            if args.pkg_name and 'name' in item and \
                    args.pkg_name != item['name']:
                # debug("Skipping %s (--pkg-name=%s specified)" %
                #       (pkgname, args.pkg_name))
                continue

            try:
                pkg_db = get_pkg_revisions(item, usn_db, errors)
            except ValueError as e:
                if 'name' not in item:
                    _add_error(item['name'], errors, "%s" % e)
                continue

            try:
                rc = email_report(pkg_db, seen_db)
            except Exception as e:
                _add_error(pkg_db['name'], errors, "%s" % e)
                continue

            if rc is False:
                debug("Skipped email for '%s': up to date" % pkg_db['name'])

            if args.seen_db:
                update_seen(args.seen_db, seen_db, pkg_db)

        if len(errors) > 0:
            for p in errors:
                for e in errors[p]:
                    warn("%s: %s" % (p, e))


if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt:
        print("Aborted.")
        sys.exit(1)
