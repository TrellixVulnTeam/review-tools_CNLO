#!/usr/bin/python3
# Copyright (C) 2018 Canonical Ltd.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; version 3 of the License.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

#
# NOTE: the initial implementation of this has no store integration support
# and will look at:
# - USN db for usn information (ie, only packages in main and restricted from
#   Ubuntu are reported). The USN db will only move forward with USNs only
#   being added and not removed.
# - raw store db (contains only revisions that currently in a channel or
#   track/channel). Because the store db contains only the current published
#   revisions, as new snap revisions are published, old snap revisions will
#   be removed. Note that only snaps built with snapcraft using
#   SNAPCRAFT_BUILD_INFO=1 will appear in the raw store db.
#
# The overall intent of this implementation is to inform, not nag. As such:
# - a new snap with no previous revisions will have all USNs that affect it
#   reported. Nothing is reported if no USNs affect it
# - a snap that previously had USNs reported where the revision is unchanged
#   but a new USN affects it will only have the new USN reported
# - a snap that is reverted to an older revision (ie, this revision, though
#   older, is new in the raw store db) with USNs that affect it will have all
#   USNs reported
#
# The 'seen db' will be used to control when reports are sent
#

import argparse
import os
import pprint
import sys
import textwrap

import clickreviews.common as common
import clickreviews.available as available

from clickreviews.common import (
    debug,
    error,
    warn,
    read_file_as_json_dict,
    _add_error,  # make a class
    get_snap_manifest,
)
from clickreviews.store import (
    get_pkg_revisions,
    get_shared_snap_without_override,
    get_secnots_for_manifest,
)
from clickreviews.usn import (
    read_usn_db,
)


def main():
    common.REPORT_OUTPUT = "console"
    parser = argparse.ArgumentParser(
        prog='snap-updates-available',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        description='Show report of available security updates',
        epilog=textwrap.dedent('''\
            Typical usage:
            $ %s --usn-db=/usn/db --store-db=/store/db --seen-db=/seen/db
        ''' % os.path.basename(sys.argv[0])))

    parser.add_argument('--snap', type=str,
                        help='use manifest.yaml from snap')
    parser.add_argument('--check-shared-publishers',
                        help='Report snaps missing publisher overrides',
                        action='store_true')
    parser.add_argument('--usn-db', type=str,
                        help='USN database (json)')
    parser.add_argument('--store-db', type=str,
                        help='Raw store db (json)')
    parser.add_argument('--seen-db', type=str,
                        help='Previously seen db (json)')
    parser.add_argument('--pkg-name', type=str,
                        help='Limit report to package name')
    args = parser.parse_args()

    # XXX: for as nice as argparse is, our arg processing is less than clear
    if args.check_shared_publishers:
        if args.snap:
            error("--snap should not be used with --check-shared-publishers")

        if not args.store_db:
            error("Must specify --store-db with --check-shared-publishers")
        store_db = read_file_as_json_dict(args.store_db)
        report = get_shared_snap_without_override(store_db)

        if len(report) != 0:
            print("The following snaps are missing from overrides.py:\n")
            for eml in sorted(report):
                print("%s:\n- %s" % (eml, "\n- ".join(report[eml])))
            # pprint.pprint(report)

        return

    if args.snap:
        if not args.usn_db:
            error("Must specify --usn-db with --snap")
        if args.store_db:
            error("Must not specify --store-db with --snap")

    if not args.snap and not args.store_db:
        error("Must specify --snap or --store-db")

    usn_db = read_usn_db(args.usn_db)

    if args.snap:
        m = get_snap_manifest(args.snap)

        report = get_secnots_for_manifest(m, usn_db)
        if len(report) != 0:
            pprint.pprint(report)
    elif args.store_db:
        store_db = read_file_as_json_dict(args.store_db)

        if args.seen_db:
            seen_db = available.read_seen_db(args.seen_db)
        else:
            seen_db = {}

        errors = {}
        # TODO: capture these continues errors at the end
        for item in store_db:
            if args.pkg_name and 'name' in item and \
                    args.pkg_name != item['name']:
                # debug("Skipping %s (--pkg-name=%s specified)" %
                #       (pkgname, args.pkg_name))
                continue

            try:
                pkg_db = get_pkg_revisions(item, usn_db, errors)
            except ValueError as e:
                if 'name' not in item:
                    _add_error(item['name'], errors, "%s" % e)
                continue

            try:
                rc = available.email_report(pkg_db, seen_db)
            except Exception as e:
                _add_error(pkg_db['name'], errors, "%s" % e)
                continue

            if rc is False:
                debug("Skipped email for '%s': up to date" % pkg_db['name'])

            if args.seen_db:
                available.update_seen(args.seen_db, seen_db, pkg_db)

        if len(errors) > 0:
            for p in errors:
                for e in errors[p]:
                    warn("%s: %s" % (p, e))


if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt:
        print("Aborted.")
        sys.exit(1)
